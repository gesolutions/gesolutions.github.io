<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü™Å Interactive Kite Aerodynamics Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: crosshair;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .wind-speed-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            padding: 15px 35px;
            border-radius: 10px;
            font-size: 2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            border: 2px solid #00ff00;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .wind-speed-display.active {
            opacity: 1;
        }

        .effect-box {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95), rgba(118, 75, 162, 0.95));
            color: white;
            padding: 25px 35px;
            border-radius: 15px;
            font-size: 1.1em;
            max-width: 650px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
            animation: slideInUp 0.5s ease-out forwards, fadeOutDown 0.5s ease-in 3.5s forwards;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes fadeOutDown {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(30px);
            }
        }

        .effect-box .title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .effect-box .result {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #FFF;
        }

        .effect-box .reason {
            font-size: 0.95em;
            color: #E0E0E0;
            font-style: italic;
            line-height: 1.5;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 10px;
            margin-top: 10px;
        }

        .effect-box .formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin-top: 8px;
            border-left: 3px solid #FFD700;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-size: 2.5em;
            color: white;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .loading-bar {
            width: 400px;
            height: 15px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: white;
            width: 0%;
            animation: loadingProgress 2s ease-out forwards;
        }

        @keyframes loadingProgress {
            to { width: 100%; }
        }

        .help-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(102, 126, 234, 0.9);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            z-index: 999;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }

        .help-btn:hover {
            transform: scale(1.1) rotate(15deg);
        }

        .help-menu {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 998;
            display: none;
            max-width: 350px;
            max-height: 70vh;
            overflow-y: auto;
            border: 2px solid rgba(102, 126, 234, 0.5);
        }

        .help-menu.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .help-menu h3 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .help-menu ul {
            list-style: none;
            padding: 0;
        }

        .help-menu li {
            padding: 8px 0;
            font-size: 0.9em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .help-menu kbd {
            background: rgba(102, 126, 234, 0.8);
            padding: 3px 8px;
            border-radius: 3px;
            font-family: monospace;
            margin-right: 8px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loading-text">ü™Å Initializing Physics Engine...</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
    </div>

    <button class="help-btn" onclick="toggleHelp()">‚ùì</button>
    
    <div class="help-menu" id="helpMenu">
        <h3>‚å®Ô∏è Controls</h3>
        <ul>
            <li><kbd>Mouse Move</kbd> Wind direction & speed</li>
            <li><kbd>Click</kbd> Create hole</li>
            <li><kbd>Shift+Click</kbd> Multiple holes</li>
            <li><kbd>Ctrl+Click</kbd> Create tear</li>
            <li><kbd>Alt+Click</kbd> Add weight</li>
            <li><kbd>Right Click</kbd> Reduce tension</li>
            <li><kbd>C</kbd> Cut string (kite spins!)</li>
            <li><kbd>Scroll Up</kbd> Increase altitude</li>
            <li><kbd>Scroll Down</kbd> Decrease altitude</li>
            <li><kbd>W</kbd> Turbulence</li>
            <li><kbd>G</kbd> Gust</li>
            <li><kbd>T</kbd> Thermal updraft</li>
            <li><kbd>Q</kbd> Left crosswind</li>
            <li><kbd>E</kbd> Right crosswind</li>
            <li><kbd>R</kbd> Reset</li>
            <li><kbd>Space</kbd> Pause/Resume</li>
        </ul>
    </div>

    <div class="wind-speed-display" id="windSpeedDisplay"></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        const physics = {
            windSpeed: 8,
            windAngle: 0,
            mouseWindSpeed: 0,
            kiteAngle: 25,
            lineLength: 50,
            altitude: 50,
            lift: 0,
            drag: 0,
            CL: 0,
            CD: 0,
            holes: [],
            tears: [],
            weights: [],
            turbulence: false,
            gust: false,
            thermal: false,
            crosswind: 0,
            spineBend: 0,
            camber: 0.1,
            AIR_DENSITY: 1.225,
            KITE_AREA: 0.5,
            KITE_MASS: 0.15,
            isPaused: false,
            stringCut: false,
            spinSpeed: 0
        };

        const boy = {
            x: canvas.width / 2,
            y: canvas.height * 0.85,
            armAngle: 0
        };

        const kite = {
            x: canvas.width / 2,
            y: canvas.height * 0.25,
            targetY: canvas.height * 0.25,
            width: 80,
            height: 100,
            rotation: 0,
            oscillation: 0
        };

        const clouds = [];
        const birds = [];
        const palmTrees = [
            { x: 100, y: canvas.height * 0.7, scale: 1.2, sway: 0 },
            { x: canvas.width - 150, y: canvas.height * 0.7, scale: 1.0, sway: 0 },
            { x: 300, y: canvas.height * 0.75, scale: 0.9, sway: 0 }
        ];

        for (let i = 0; i < 6; i++) {
            clouds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.3 + 50,
                width: Math.random() * 150 + 100,
                height: Math.random() * 60 + 40,
                speed: Math.random() * 0.5 + 0.2
            });
        }

        for (let i = 0; i < 10; i++) {
            birds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.4 + 50,
                speed: Math.random() * 2 + 1,
                wingPhase: Math.random() * Math.PI * 2,
                size: Math.random() * 12 + 8
            });
        }

        const airflowParticles = [];
        const vortexParticles = [];
        const damageParticles = [];

        for (let i = 0; i < 80; i++) {
            airflowParticles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0,
                vy: 0,
                size: Math.random() * 3 + 1,
                opacity: Math.random() * 0.5 + 0.3
            });
        }

        const mouse = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            prevX: canvas.width / 2,
            prevY: canvas.height / 2,
            isDown: false,
            history: [],
            isMoving: false,
            moveTimeout: null,
            lastWindSpeed: 0
        };

        const keys = {};
        const windSpeedDisplay = document.getElementById('windSpeedDisplay');
        const shownEffects = new Set();

        canvas.addEventListener('mousemove', (e) => {
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            
            mouse.history.push({ x: mouse.x, y: mouse.y, time: Date.now() });
            if (mouse.history.length > 20) mouse.history.shift();
            
            mouse.isMoving = true;
            
            if (mouse.moveTimeout) clearTimeout(mouse.moveTimeout);
            mouse.moveTimeout = setTimeout(() => handleMouseStop(), 300);
            
            handleMouseMove();
        });

        canvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            handleClick(e);
        });

        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            handleRightClick(e);
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            handleScroll(e);
        });

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            handleKeyPress(e.key.toLowerCase());
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function updateWindSpeedDisplay(speed) {
            if (speed > 1) {
                windSpeedDisplay.innerHTML = `üå™Ô∏è WIND: ${speed.toFixed(1)} m/s (${(speed * 3.6).toFixed(1)} km/h)`;
                windSpeedDisplay.classList.add('active');
                mouse.lastWindSpeed = speed;
            } else {
                windSpeedDisplay.classList.remove('active');
            }
        }

        function hideWindSpeedDisplay() {
            windSpeedDisplay.classList.remove('active');
        }

        function showEffect(title, result, reason, formula = null) {
            const effectKey = title;
            if (shownEffects.has(effectKey)) return;
            
            shownEffects.add(effectKey);
            setTimeout(() => shownEffects.delete(effectKey), 5000);
            
            const div = document.createElement('div');
            div.className = 'effect-box';
            
            let html = `
                <div class="title">‚ö° ${title}</div>
                <div class="result">üìä ${result}</div>
                <div class="reason">üî¨ ${reason}</div>
            `;
            
            if (formula) {
                html += `<div class="formula">${formula}</div>`;
            }
            
            div.innerHTML = html;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 4000);
        }

        function calculateWindSpeed() {
            const dx = mouse.x - mouse.prevX;
            const dy = mouse.y - mouse.prevY;
            const speed = Math.sqrt(dx * dx + dy * dy);
            
            physics.mouseWindSpeed = speed * 0.1;
            const effectiveSpeed = physics.windSpeed + physics.mouseWindSpeed;
            
            if (mouse.isMoving) {
                updateWindSpeedDisplay(effectiveSpeed);
            }
            
            return effectiveSpeed;
        }

        function calculateForces() {
            const effectiveWind = physics.windSpeed + physics.mouseWindSpeed + 
                                  (physics.gust ? 5 : 0) + 
                                  (physics.thermal ? 3 : 0);
            
            const q = 0.5 * physics.AIR_DENSITY * effectiveWind * effectiveWind;
            
            const alpha = physics.kiteAngle;
            let CL = 2 * Math.PI * (alpha * Math.PI / 180) * (1 + physics.camber);
            CL = Math.min(CL, 1.5);
            
            if (alpha > 45) {
                CL *= (1 - (alpha - 45) / 45);
                CL = Math.max(0, CL);
            }
            
            let CD = 0.04 + (CL * CL) / (Math.PI * 3.5) + 0.02;
            
            const totalHoleDamage = physics.holes.reduce((sum, h) => {
                return sum + (h.opacity || 1) * h.size * 0.01;
            }, 0);
            
            CL *= (1 - totalHoleDamage * 0.5);
            CD += totalHoleDamage * 0.2;
            
            const tearDamage = physics.tears.length * 0.05;
            CL *= (1 - tearDamage);
            CD += tearDamage * 0.15;
            
            physics.CL = CL;
            physics.CD = CD;
            physics.lift = q * CL * physics.KITE_AREA;
            physics.drag = q * CD * physics.KITE_AREA;
            
            return { CL, CD, lift: physics.lift, drag: physics.drag };
        }

        function detectCircularMotion() {
            if (mouse.history.length < 15) return false;
            
            let angleSum = 0;
            for (let i = 2; i < mouse.history.length; i++) {
                const p1 = mouse.history[i - 2];
                const p2 = mouse.history[i - 1];
                const p3 = mouse.history[i];
                
                const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                
                let diff = angle2 - angle1;
                if (diff > Math.PI) diff -= 2 * Math.PI;
                if (diff < -Math.PI) diff += 2 * Math.PI;
                
                angleSum += diff;
            }
            
            return Math.abs(angleSum) > Math.PI * 1.5;
        }

        function handleMouseMove() {
            calculateWindSpeed();
            
            const dx = mouse.x - kite.x;
            const dy = mouse.y - kite.y;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            physics.windAngle = angle * 0.05;
            
            if (detectCircularMotion()) {
                showEffect(
                    'CIRCULAR MOTION DETECTED',
                    'Kite enters spinning mode, centrifugal force increases',
                    'Combined centripetal acceleration (a = v¬≤/r) and aerodynamic torque creates rotational momentum. Angular velocity increases as radius decreases.',
                    'F_centripetal = m¬∑v¬≤/r, œÑ = r √ó F'
                );
                
                kite.rotation += 0.1;
                mouse.history = [];
            }
        }

        function handleMouseStop() {
            mouse.isMoving = false;
            hideWindSpeedDisplay();
            
            if (mouse.lastWindSpeed > 10) {
                const effectiveSpeed = mouse.lastWindSpeed;
                const gustLift = 0.5 * physics.AIR_DENSITY * effectiveSpeed * effectiveSpeed * physics.CL * physics.KITE_AREA;
                
                showEffect(
                    'WIND EFFECT DETECTED',
                    `Peak wind velocity: ${effectiveSpeed.toFixed(1)} m/s (${(effectiveSpeed * 3.6).toFixed(1)} km/h), lift force: ${gustLift.toFixed(2)}N`,
                    'Rapid mouse movement simulates wind gust. Dynamic pressure (q = ¬ΩœÅv¬≤) increases quadratically with velocity. Since lift L = q¬∑C_L¬∑A, a 50% wind increase causes 125% lift increase.',
                    'L = ¬ΩœÅv¬≤C_L A, if v ‚Üë 50% then L ‚Üë 125%'
                );
            }
            
            mouse.lastWindSpeed = 0;
        }

        function handleClick(e) {
            const dx = mouse.x - kite.x;
            const dy = mouse.y - kite.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 100) {
                if (e.shiftKey) {
                    for (let i = 0; i < 3; i++) {
                        physics.holes.push({
                            x: kite.x + (Math.random() - 0.5) * 60,
                            y: kite.y + (Math.random() - 0.5) * 60,
                            size: Math.random() * 8 + 5,
                            opacity: 1
                        });
                    }
                    
                    showEffect(
                        'MULTIPLE HOLES - ASYMMETRIC DAMAGE',
                        `3 holes created, lift reduced significantly, kite descending`,
                        'Multiple pressure leaks create asymmetric pressure distribution. Uneven lift generates rolling moment (M = ŒîL √ó b/2) causing lateral instability. As lift decreases below weight, kite altitude drops.',
                        'ŒîP = P_upper - P_lower decreases, M_roll = ŒîL √ó (wingspan/2)'
                    );
                    
                    createDamageParticles(kite.x, kite.y, 25);
                    
                } else if (e.ctrlKey) {
                    physics.tears.push({
                        x1: kite.x + dx * 0.3,
                        y1: kite.y + dy * 0.3,
                        x2: kite.x + dx * 0.6,
                        y2: kite.y + dy * 0.6
                    });
                    
                    showEffect(
                        'EDGE TEAR PROPAGATION',
                        'Fabric tear created, drag increased by 20%, structural integrity compromised',
                        'Tear disrupts laminar flow, causing early boundary layer separation. Parasitic drag increases due to turbulent wake.',
                        'D_total = D_form + D_skin + D_induced'
                    );
                    
                    createDamageParticles(kite.x + dx * 0.5, kite.y + dy * 0.5, 15);
                    
                } else if (e.altKey) {
                    physics.weights.push({
                        x: kite.x + dx * 0.5,
                        y: kite.y + dy * 0.5,
                        mass: 0.05
                    });
                    
                    showEffect(
                        'WEIGHT DISTRIBUTION CHANGE',
                        'Added 50g weight, center of gravity shifted, kite tilts toward weighted side',
                        'Center of gravity (CG) displacement creates torque about center of pressure (CP). Rotational equilibrium disturbed: Œ£œÑ = r √ó F ‚â† 0.',
                        'œÑ = r √ó F, where r = distance from CG to CP'
                    );
                    
                } else {
                    const holeSize = Math.random() * 12 + 8;
                    physics.holes.push({
                        x: kite.x + dx * 0.5,
                        y: kite.y + dy * 0.5,
                        size: holeSize,
                        opacity: 1
                    });
                    
                    const holeArea = Math.PI * holeSize * holeSize;
                    const liftReduction = (holeArea / (physics.KITE_AREA * 10000) * 50).toFixed(1);
                    
                    showEffect(
                        'SURFACE HOLE CREATED',
                        `Hole diameter: ${(holeSize * 2).toFixed(1)}mm, lift reduced by ${liftReduction}%, pressure leak detected`,
                        'Air leaks through hole from high-pressure (lower surface) to low-pressure (upper surface) region. This reduces pressure differential (ŒîP), directly decreasing lift force.',
                        `L_damaged = L_original √ó (1 - A_hole/A_total)`
                    );
                    
                    createDamageParticles(kite.x + dx * 0.5, kite.y + dy * 0.5, 12);
                }
            }
        }

        function handleRightClick(e) {
            const dx = mouse.x - kite.x;
            const dy = mouse.y - kite.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 100) {
                physics.spineBend = 0.5;
                
                showEffect(
                    'SAIL TENSION ASYMMETRY',
                    'Fabric tension reduced on one side, local lift coefficient increased, rolling moment generated',
                    'Loose fabric creates increased camber locally, enhancing lift (C_L,local = C_L,base √ó (1 + camber)). Asymmetric lift distribution induces roll.',
                    'C_L increases with camber, M_roll = ŒîL √ó (wingspan/2)'
                );
                
                setTimeout(() => { physics.spineBend = 0; }, 2000);
            }
        }

        function handleScroll(e) {
            if (e.deltaY < 0) {
                physics.lineLength = Math.max(20, physics.lineLength - 5);
                kite.targetY = Math.max(50, kite.targetY - 15);
                physics.altitude += 5;
                
                showEffect(
                    'ALTITUDE INCREASE',
                    `Line shortened to ${physics.lineLength}m, altitude: ${physics.altitude}m, tension increased`,
                    'Reducing line length increases angle of attack and line tension. Wind speed also increases with altitude (wind shear effect).',
                    'v_altitude = v_0 √ó (1 + 0.1√óln(h/10))'
                );
                
            } else {
                physics.lineLength = Math.min(150, physics.lineLength + 5);
                kite.targetY = Math.min(canvas.height * 0.5, kite.targetY + 15);
                physics.altitude = Math.max(10, physics.altitude - 5);
                
                showEffect(
                    'ALTITUDE DECREASE',
                    `Line extended to ${physics.lineLength}m, altitude: ${physics.altitude}m, kite descends`,
                    'Increased line length reduces angle of attack and effective lift. Gravitational potential energy converts to kinetic energy during descent.',
                    'PE = mgh, KE = ¬Ωmv¬≤'
                );
            }
        }

        function handleKeyPress(key) {
            switch(key) {
                case 'c':
                    if (!physics.stringCut) {
                        physics.stringCut = true;
                        physics.spinSpeed = 0.05;
                        
                        showEffect(
                            'STRING CUT - FREE FLIGHT MODE',
                            'Tension released, kite enters uncontrolled spin, asymmetric forces dominate',
                            'Without string tension constraint, any small aerodynamic asymmetry (damage, wind variation) creates unconstrained torque. Kite spins due to: 1) Asymmetric lift from holes/tears 2) Magnus effect from rotation 3) No restoring moment from bridle.',
                            'Œ£œÑ ‚â† 0, œâ increases, Magnus force: F_M ‚àù œâ √ó v'
                        );
                    }
                    break;
                    
                case 'w':
                    physics.turbulence = true;
                    showEffect(
                        'TURBULENT WIND ACTIVATED',
                        'Random wind gusts detected, kite experiences rapid oscillations and flutter',
                        'Reynolds number exceeds 10‚Åµ, flow transitions from laminar to turbulent. Vortex shedding causes periodic pressure fluctuations.',
                        'Re = œÅvL/Œº > 10‚Åµ, f_vortex = St √ó v/d'
                    );
                    setTimeout(() => { physics.turbulence = false; }, 3000);
                    break;
                    
                case 'g':
                    physics.gust = true;
                    kite.targetY -= 40;
                    showEffect(
                        'SUDDEN WIND GUST',
                        `Gust velocity increased, instantaneous lift spike, rapid altitude gain`,
                        'Gust represents sudden increase in dynamic pressure (q = ¬ΩœÅv¬≤). Since lift is proportional to v¬≤, wind increase causes dramatic lift increase.',
                        'L = ¬ΩœÅv¬≤C_L A'
                    );
                    setTimeout(() => { 
                        physics.gust = false;
                        kite.targetY += 40;
                    }, 1500);
                    break;
                    
                case 't':
                    physics.thermal = true;
                    showEffect(
                        'THERMAL UPDRAFT DETECTED',
                        'Rising column of warm air, vertical wind component +3 m/s, sustained altitude gain',
                        'Solar heating creates convective cells. Warm air rises (Archimedes principle), creating vertical wind component.',
                        'F_buoyancy = œÅ_air √ó g √ó V_displaced'
                    );
                    setTimeout(() => { physics.thermal = false; }, 3000);
                    break;
                    
                case 'q':
                    physics.crosswind = -20;
                    showEffect(
                        'LEFT CROSSWIND',
                        'Lateral wind component from left, kite drifts right, yaw moment generated',
                        'Crosswind creates side force and yaw moment. Effective wind velocity vector changes.',
                        'v_eff = ‚àö(v_forward¬≤ + v_lateral¬≤)'
                    );
                    setTimeout(() => { physics.crosswind = 0; }, 2500);
                    break;
                    
                case 'e':
                    physics.crosswind = 20;
                    showEffect(
                        'RIGHT CROSSWIND',
                        'Lateral wind component from right, kite drifts left, sideslip angle increases',
                        'Sideslip angle (Œ≤) creates differential pressure on left/right surfaces.',
                        'F_side = ¬ΩœÅv¬≤C_Y A'
                    );
                    setTimeout(() => { physics.crosswind = 0; }, 2500);
                    break;
                    
                case 'r':
                    resetSimulation();
                    showEffect(
                        'SIMULATION RESET',
                        'All damage cleared, kite restored to optimal condition',
                        'System returns to equilibrium state where sum of forces equals zero: Œ£F = 0.',
                        'Œ£F_vertical = 0: L = W'
                    );
                    break;
                    
                case ' ':
                    physics.isPaused = !physics.isPaused;
                    showEffect(
                        physics.isPaused ? 'SIMULATION PAUSED' : 'SIMULATION RESUMED',
                        physics.isPaused ? 'Time frozen, all forces suspended' : 'Physics calculations resumed',
                        physics.isPaused ? 'Temporal dimension halted' : 'Real-time integration active',
                        physics.isPaused ? 'dE/dt = 0' : 'dx/dt = v'
                    );
                    break;
            }
        }

        function resetSimulation() {
            physics.holes = [];
            physics.tears = [];
            physics.weights = [];
            physics.turbulence = false;
            physics.gust = false;
            physics.thermal = false;
            physics.spineBend = 0;
            physics.crosswind = 0;
            physics.kiteAngle = 25;
            physics.stringCut = false;
            physics.spinSpeed = 0;
            kite.y = canvas.height * 0.25;
            kite.targetY = canvas.height * 0.25;
            kite.rotation = 0;
            shownEffects.clear();
        }

        function createDamageParticles(x, y, count) {
            for (let i = 0; i < count; i++) {
                damageParticles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6 - 2,
                    life: 80,
                    maxLife: 80,
                    size: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 60}, 70%, 60%)`
                });
            }
        }

        function updateParticles() {
            for (let i = damageParticles.length - 1; i >= 0; i--) {
                const p = damageParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15;
                p.vx *= 0.98;
                p.life--;
                
                if (p.life <= 0) {
                    damageParticles.splice(i, 1);
                }
            }
            
            physics.holes.forEach(hole => {
                if (hole.opacity > 0) {
                    hole.opacity -= 0.005;
                }
            });
            
            physics.holes = physics.holes.filter(hole => hole.opacity > 0);
            
            airflowParticles.forEach(p => {
                const windEffect = physics.windSpeed + physics.mouseWindSpeed;
                p.vx = windEffect * 0.15;
                
                if (physics.turbulence) {
                    p.vx += (Math.random() - 0.5) * 2;
                    p.vy = (Math.random() - 0.5) * 2;
                } else {
                    p.vy = (Math.random() - 0.5) * 0.3;
                }
                
                p.x += p.vx;
                p.y += p.vy;
                
                if (p.x > canvas.width) p.x = 0;
                if (p.x < 0) p.x = canvas.width;
                if (p.y > canvas.height) p.y = 0;
                if (p.y < 0) p.y = canvas.height;
            });
            
            if (Math.random() < 0.15 && physics.windSpeed > 3) {
                vortexParticles.push(
                    {
                        x: kite.x - kite.width / 2,
                        y: kite.y,
                        vx: -2,
                        vy: 1,
                        rotation: 0,
                        life: 120,
                        maxLife: 120,
                        direction: 1
                    },
                    {
                        x: kite.x + kite.width / 2,
                        y: kite.y,
                        vx: 2,
                        vy: 1,
                        rotation: 0,
                        life: 120,
                        maxLife: 120,
                        direction: -1
                    }
                );
            }
            
            for (let i = vortexParticles.length - 1; i >= 0; i--) {
                const v = vortexParticles[i];
                v.x += v.vx + physics.windSpeed * 0.15;
                v.y += v.vy;
                v.rotation += 0.08 * v.direction;
                v.life--;
                
                if (v.life <= 0) {
                    vortexParticles.splice(i, 1);
                }
            }
        }

        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.5, '#FFB6C1');
            gradient.addColorStop(1, '#FFE5B4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.7);
        }

        function drawSun() {
            const sunX = canvas.width * 0.85;
            const sunY = canvas.height * 0.15;
            const sunRadius = 50;
            
            const glow = ctx.createRadialGradient(sunX, sunY, sunRadius * 0.5, sunX, sunY, sunRadius * 2.5);
            glow.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
            glow.addColorStop(0.4, 'rgba(255, 255, 150, 0.4)');
            glow.addColorStop(1, 'rgba(255, 255, 100, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius * 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();
            
            const time = Date.now() * 0.0005;
            ctx.save();
            ctx.translate(sunX, sunY);
            ctx.rotate(time);
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const length = sunRadius * 1.6;
                
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * sunRadius, Math.sin(angle) * sunRadius);
                ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawClouds() {
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > canvas.width + cloud.width) {
                    cloud.x = -cloud.width;
                }
                
                ctx.fillStyle = `rgba(255, 255, 255, 0.85)`;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.height / 2, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.width / 3, cloud.y - cloud.height / 4, cloud.height / 1.5, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.width / 1.5, cloud.y, cloud.height / 1.8, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.width, cloud.y + cloud.height / 5, cloud.height / 2.2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBirds() {
            const time = Date.now() * 0.001;
            
            birds.forEach(bird => {
                bird.x += bird.speed;
                if (bird.x > canvas.width + 50) {
                    bird.x = -50;
                    bird.y = Math.random() * canvas.height * 0.4 + 50;
                }
                
                const wingAngle = Math.sin(time * 5 + bird.wingPhase) * 0.6;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.arc(bird.x - bird.size / 2, bird.y, bird.size, Math.PI + wingAngle, Math.PI * 1.5 - wingAngle);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(bird.x + bird.size / 2, bird.y, bird.size, Math.PI * 1.5 + wingAngle, Math.PI * 2 - wingAngle);
                ctx.stroke();
            });
        }

        function drawOcean() {
            const oceanY = canvas.height * 0.7;
            
            const gradient = ctx.createLinearGradient(0, oceanY, 0, canvas.height);
            gradient.addColorStop(0, '#4FC3F7');
            gradient.addColorStop(0.3, '#29B6F6');
            gradient.addColorStop(0.7, '#0288D1');
            gradient.addColorStop(1, '#01579B');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, oceanY, canvas.width, canvas.height - oceanY);
            
            const time = Date.now() * 0.001;
            
            for (let layer = 0; layer < 4; layer++) {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 - layer * 0.08})`;
                ctx.lineWidth = 3;
                
                for (let i = 0; i <= canvas.width; i += 8) {
                    const amplitude = 12 - layer * 2;
                    const frequency = 0.015 + layer * 0.003;
                    const y = oceanY + layer * 25 + Math.sin(i * frequency + time * 2 + layer) * amplitude;
                    
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
            }
            
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = oceanY + Math.random() * (canvas.height * 0.15);
                const size = Math.random() * 3 + 1;
                const alpha = Math.sin(time * 3 + i) * 0.5 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBeach() {
            const beachY = canvas.height * 0.85;
            
            const gradient = ctx.createLinearGradient(0, beachY, 0, canvas.height);
            gradient.addColorStop(0, '#F4E4C1');
            gradient.addColorStop(0.5, '#E6D5A8');
            gradient.addColorStop(1, '#D4C4A0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, beachY, canvas.width, canvas.height - beachY);
            
            ctx.fillStyle = 'rgba(210, 180, 140, 0.25)';
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * canvas.width;
                const y = beachY + Math.random() * (canvas.height - beachY);
                const size = Math.random() * 2 + 1;
                ctx.fillRect(x, y, size, size);
            }
        }

        function drawPalmTree(tree) {
            const time = Date.now() * 0.001;
            const windEffect = (physics.windSpeed + physics.mouseWindSpeed) / 10;
            tree.sway = Math.sin(time * 0.8 + tree.x * 0.01) * 8 * windEffect;
            
            ctx.save();
            ctx.translate(tree.x, tree.y);
            ctx.scale(tree.scale, tree.scale);
            
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 18;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(tree.sway * 0.5, -60, tree.sway * 1.2, -140);
            ctx.stroke();
            
            for (let i = 0; i < 8; i++) {
                ctx.strokeStyle = '#A0522D';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(tree.sway * 0.3, -i * 18, 12, Math.PI, 0);
                ctx.stroke();
            }
            
            ctx.save();
            ctx.translate(tree.sway * 1.2, -140);
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 0.1;
                
                ctx.save();
                ctx.rotate(angle);
                
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(15, -25, 20, -55);
                ctx.stroke();
                
                ctx.fillStyle = '#2E8B57';
                ctx.beginPath();
                ctx.ellipse(15, -40, 8, 45, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            ctx.restore();
            ctx.restore();
        }

        function drawBoy() {
            const time = Date.now() * 0.001;
            boy.armAngle = Math.sin(time * 1.5) * 0.15;
            
            ctx.save();
            ctx.translate(boy.x, boy.y);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(0, 50, 20, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#2C3E50';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(-5, 20);
            ctx.lineTo(-10, 48);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(5, 20);
            ctx.lineTo(10, 48);
            ctx.stroke();
            
            ctx.strokeStyle = '#3498DB';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(0, 20);
            ctx.stroke();
            
            ctx.strokeStyle = '#FFD9B3';
            ctx.lineWidth = 5;
            
            ctx.beginPath();
            ctx.moveTo(-5, -10);
            ctx.lineTo(-18, 5 + Math.sin(time * 2) * 4);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(5, -10);
            ctx.lineTo(18, -8 + boy.armAngle * 15);
            ctx.stroke();
            
            ctx.fillStyle = '#FFD9B3';
            ctx.beginPath();
            ctx.arc(0, -28, 16, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#2C3E50';
            ctx.beginPath();
            ctx.arc(0, -33, 16, Math.PI, 0);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-5, -28, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -28, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, -25, 6, 0.2, Math.PI - 0.2);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawString() {
            if (physics.stringCut) return;
            
            ctx.save();
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            
            ctx.beginPath();
            ctx.moveTo(boy.x + 18, boy.y - 8);
            
            const controlX = (boy.x + kite.x) / 2 + (physics.windSpeed + physics.mouseWindSpeed) * 4;
            const controlY = (boy.y + kite.y) / 2;
            
            ctx.quadraticCurveTo(controlX, controlY, kite.x, kite.y + kite.height / 2);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            if (physics.windSpeed + physics.mouseWindSpeed > 12) {
                const vibration = Math.sin(Date.now() * 0.02) * 3;
                ctx.beginPath();
                ctx.moveTo(boy.x + 18, boy.y - 8);
                ctx.quadraticCurveTo(controlX + vibration, controlY, kite.x, kite.y + kite.height / 2);
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawKite() {
            if (physics.isPaused) return;
            
            const time = Date.now() * 0.001;
            
            calculateForces();
            
            kite.oscillation = Math.sin(time * 2) * (8 + physics.windSpeed);
            
            if (physics.turbulence) {
                kite.oscillation += (Math.random() - 0.5) * 25;
            }
            
            // Kite descends if too many holes
            const holeDamage = physics.holes.reduce((sum, h) => sum + (h.opacity || 1) * h.size * 0.01, 0);
            if (holeDamage > 0.3) {
                kite.targetY += 0.5; // Gradual descent
            }
            
            kite.y += (kite.targetY - kite.y) * 0.05;
            
            const mouseInfluence = (mouse.x - kite.x) * 0.008;
            kite.x += mouseInfluence + (physics.crosswind * 0.1);
            kite.x = Math.max(100, Math.min(canvas.width - 100, kite.x));
            
            const displayX = kite.x + kite.oscillation;
            const displayY = kite.y + (physics.thermal ? -25 : 0) + (physics.gust ? -15 : 0);
            
            // Rotation
            let targetRotation = physics.windAngle * 0.3 + physics.spineBend * 0.5;
            
            // String cut - continuous spin
            if (physics.stringCut) {
                kite.rotation += physics.spinSpeed;
                physics.spinSpeed *= 1.02; // Accelerate
                kite.y += 0.3; // Fall down
            } else {
                kite.rotation += (targetRotation - kite.rotation) * 0.1;
            }
            
            ctx.save();
            ctx.translate(displayX, displayY);
            ctx.rotate(kite.rotation);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.moveTo(2, -kite.height / 2 + 5);
            ctx.lineTo(kite.width / 2 + 2, 5);
            ctx.lineTo(2, kite.height / 2 + 5);
            ctx.lineTo(-kite.width / 2 + 2, 5);
            ctx.closePath();
            ctx.fill();
            
            const gradient = ctx.createLinearGradient(-kite.width / 2, 0, kite.width / 2, 0);
            gradient.addColorStop(0, '#FF6B6B');
            gradient.addColorStop(0.3, '#FF8E53');
            gradient.addColorStop(0.7, '#FFD93D');
            gradient.addColorStop(1, '#FFA07A');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, -kite.height / 2);
            ctx.lineTo(kite.width / 2, 0);
            ctx.lineTo(0, kite.height / 2);
            ctx.lineTo(-kite.width / 2, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.strokeStyle = '#5D4E37';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(0, -kite.height / 2);
            ctx.lineTo(0, kite.height / 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-kite.width / 2, 0);
            ctx.quadraticCurveTo(0, physics.spineBend * 15, kite.width / 2, 0);
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(-kite.width / 4, -kite.height / 4, 12, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(kite.width / 4, -kite.height / 4, 12, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(0, kite.height / 2);
            
            for (let i = 1; i <= 6; i++) {
                const x = Math.sin(time * 3 + i * 0.5) * 20;
                const y = kite.height / 2 + i * 18;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            for (let i = 1; i <= 5; i++) {
                const x = Math.sin(time * 3 + i * 0.5) * 20;
                const y = kite.height / 2 + i * 18;
                
                ctx.fillStyle = i % 2 === 0 ? '#FFD93D' : '#FF6B6B';
                ctx.beginPath();
                ctx.arc(x - 8, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 8, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // Draw damage with fading
            physics.holes.forEach(hole => {
                const alpha = hole.opacity || 1;
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(102, 102, 102, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            physics.tears.forEach(tear => {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(tear.x1, tear.y1);
                ctx.lineTo(tear.x2, tear.y2);
                ctx.stroke();
            });
            
            physics.weights.forEach(weight => {
                ctx.fillStyle = '#424242';
                ctx.beginPath();
                ctx.arc(weight.x, weight.y, 7, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawParticles() {
            airflowParticles.forEach(p => {
                ctx.fillStyle = `rgba(200, 220, 255, ${p.opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            vortexParticles.forEach(v => {
                const alpha = v.life / v.maxLife;
                
                ctx.save();
                ctx.translate(v.x, v.y);
                ctx.rotate(v.rotation);
                
                ctx.strokeStyle = `rgba(102, 126, 234, ${alpha * 0.7})`;
                ctx.lineWidth = 3;
                
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const r = 18;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            damageParticles.forEach(p => {
                const alpha = p.life / p.maxLife;
                const color = p.color.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawSky();
            drawSun();
            drawClouds();
            drawBirds();
            drawOcean();
            drawBeach();
            
            palmTrees.forEach(tree => drawPalmTree(tree));
            
            drawBoy();
            drawString();
            drawKite();
            
            updateParticles();
            drawParticles();
            
            requestAnimationFrame(animate);
        }

        function toggleHelp() {
            const menu = document.getElementById('helpMenu');
            menu.classList.toggle('active');
        }

        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
            animate();
        }, 2100);
    </script>
</body>
</html>
